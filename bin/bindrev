#!/usr/bin/env python3.7

import os
import json
import time
import signal
import asyncio
import logging
import dns.message
import dns.rdatatype
import ipaddress
import mysql.connector as mysql
import aiomysql
import dnstap_client
import argparse

default_config_file = "%s/.bindrev.json" % os.path.expanduser('~')

class BufferedDb:

    def __init__(self, db):
        self.db = db
        self.ips = {}

    async def close(self):
        await self.flush()
        await self.db.close()

    async def get(self, ip):
        if ip in self.ips:
            for (domain, latest) in self.ips[ip].items():
                if latest:
                    return domain
            raise Exception("ip present, but latest not found") 
        else:
            return await self.db.get(ip)

    async def set_all(self, items):
        for (ip, domain) in items:
            if not ip in self.ips:
                self.ips[ip] = {}
            self.ips[ip][domain] = True
            for x in self.ips[ip]:
                if x != domain:
                    self.ips[ip][x] = False

    async def flush(self):
        updates = []
        for ip in self.ips:
            for (domain, latest) in self.ips[ip].items():
                if latest:
                    latest_domain = domain
                else:
                    updates.append((ip, domain,))
            updates.append((ip, latest_domain,))
        await self.db.set_all(updates)
        self.ips = {}

class MyDb:

    def __init__(self, host, db, user, password):
        self.host = host
        self.db = db
        self.user = user
        self.password = password
        self.con = None

    async def close(self):
        if not self.con is None:
            self.con.close()

    def __getcon__(self):
        # TODO, mysql is not threadsafe, so because
        # mysql commands are executed in different threads,
        # we need a new connection every time
        return mysql.connect(host=self.host, user=self.user, password=self.password, database=self.db, auth_plugin='mysql_native_password')
        if self.con is None:
            con = mysql.connect(host=self.host, user=self.user, password=self.password, database=self.db, auth_plugin='mysql_native_password')
            self.con = con
        return self.con

    def __reset__(self):
        if self.con is not None:
            try:
                # TODO, should this be async?
                self.con.close()
            except Exception as e:
                logging.error(e)
        self.con = None

    async def get(self, ip):
        loop = asyncio.get_event_loop()
        try:
            return await loop.run_in_executor(None, self._get, ip)
        except:
            self.__reset__()
            raise

    def _get(self, ip):
        con = self.__getcon__()
        curs = con.cursor()
        curs.execute("SELECT domain FROM ips WHERE ip = %s AND latest = TRUE", (str(ip),))
        results = curs.fetchall()
        if len(results) == 0:
            raise KeyError
        return results[0][0]

    async def set_all(self, items):
        loop = asyncio.get_event_loop()
        start = time.time()
        try:
            await loop.run_in_executor(None, self._set_all, items)
        except:
            self.__reset__()
            raise
        stop = time.time()
        logging.debug("set_all(size=%s): %s" % (len(items), stop - start))

    def _set_all(self, items):
        con = self.__getcon__()
        curs = con.cursor()
        for (ip, domain) in items:
            curs.execute("SELECT id, latest FROM bindrev.ips WHERE ip = %s AND domain = %s", (str(ip), domain,))
            results = curs.fetchall()
            update_others = False
            if len(results) == 0:
                curs.execute("INSERT INTO bindrev.ips (ip, domain, latest) VALUES (%s, %s, TRUE)", (str(ip), domain,))
                update_others = True
            elif len(results) == 1:
                _id = results[0][0]
                latest = results[0][1]
                if latest == False:
                    curs.execute("UPDATE bindrev.ips SET latest = TRUE WHERE id = %s" % (_id,))
                    update_others = True
            else:
                raise Exception("unexpected result count")
            if update_others:
                curs.execute("UPDATE bindrev.ips SET latest = FALSE WHERE ip = %s AND domain <> %s", (str(ip), domain,))
        con.commit()
     
class ReverseLookup:

    def __init__(self, db):
        self.db = db

    async def add(self, ip, domain):
        try:
            current = await self.get(ip)
            if current == domain:
                logging.debug("Keeping %s[%s] -> %s" % (ip, current, domain))
            else:
                logging.debug("Updating %s[%s] -> %s" % (ip, current, domain))
                await self.db.set_all([(ip, domain,)])
        except KeyError:
            logging.debug("Creating %s -> %s" % (ip, domain))
            await self.db.set_all([(ip, domain,)])

    async def get(self, ip):
        try:
            return await self.db.get(ip)
        except KeyError:
            return None

class BindrevServer:

    test_ip = ipaddress.ip_address('127.0.0.1')
    test_domain = 'localhost.'

    def __init__(self, lookup, host='0.0.0.0', port=8888):
        self.lookup = lookup
        self.host = host
        self.port = port

    async def start(self):
        async def handle(reader, writer):
            try:
                while True:
                    ip_sz = int.from_bytes(await reader.readexactly(1), byteorder='big')
                    if ip_sz == 0:
                        writer.write((0).to_bytes(1, byteorder='big'))
                        break
                    ip = ipaddress.ip_address(await reader.readexactly(ip_sz))
                    if ip == BindrevServer.test_ip:
                        domain = BindrevServer.test_domain
                    else:
                        domain = await self.lookup.get(ip)
                    if domain is None:
                        writer.write((0).to_bytes(1, byteorder='big'))
                    else:
                        domain_sz = len(domain).to_bytes(1, byteorder='big')
                        writer.write(domain_sz)
                        writer.write(domain.encode('utf-8'))
            finally:
                writer.close()

        await asyncio.start_server(handle, self.host, self.port)

async def main():
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s [%(levelname)s]: %(message)s')

    parser = argparse.ArgumentParser()
    parser.add_argument('-c', default=default_config_file, help='config file')
    args = parser.parse_args()

    with open(args.c, 'r') as infile:
        config = json.load(infile)

    my_host = config['my_host']
    my_db = config['my_db']
    my_user = config['my_user']
    my_password = config['my_password']
    mydb = MyDb(my_host, my_db, my_user, my_password)

    db = BufferedDb(mydb)
    async def flusher():
        while True:
            await asyncio.sleep(5)
            try:
                await db.flush()
            except Exception as e:
                logging.error(e)
    asyncio.create_task(flusher())

    lookup = ReverseLookup(db)

    async def tapper_callback(domain, ip):
        await lookup.add(ip, domain)

    tapper = dnstap_client.Tapper(tapper_callback)
    asyncio.create_task(tapper.loop())

    server = BindrevServer(lookup)
    await server.start()

    finish = asyncio.Event()
    def signal_handler(*args):
        finish.set()
    loop = asyncio.get_event_loop()
    loop.add_signal_handler(signal.SIGINT, signal_handler)
    loop.add_signal_handler(signal.SIGTERM, signal_handler)

    try:
        await finish.wait()
    finally:
        await db.close()

if __name__ == "__main__":
    asyncio.run(main())
