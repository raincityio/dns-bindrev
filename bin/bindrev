#!/usr/bin/env python3.7

import time
import json
import signal
import shelve
import dnstap_pb2
import asyncio
import ipaddress
import logging
import dns.message
import dns.rdatatype
import code
import ipaddress
import uvloop
import threading
import mysql.connector as mysql
import frames

import sys 
sys.path.append("/home/drew/src/arpc")
import arpc
import arpc.arpc

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s [%(levelname)s]: %(message)s')

class BufferedDb:

    def __init__(self, db):
        self.db = db
        self.ips = {}

    def close(self):
        self.flush()
        self.db.close()

    def __getitem__(self, key):
        if key in self.ips:
            for kv in self.ips[key].items():
                if kv[1] == True:
                    return kv[0]
            raise Exception("key present, but latest not found") 
        else:
            return self.db[key]

    def __setitem__(self, key, value):
        if key in self.ips:
            self.ips[key][value] = True
            for domain in self.ips[key]:
                if domain != value:
                    self.ips[key][domain] = False
        else:
            self.ips[key] = {
                value: True
            }

    def set_items(self, items):
        for (key, value) in items:
            self[key] = value

    def __contains__(self, key):
        try:
            self.__getitem__(key)
            return True
        except KeyError:
            return False

    def flush(self):
        updates = []
        for ip in self.ips:
            for (domain, latest) in self.ips[ip].items():
                if latest:
                    latest_domain = domain
                else:
                    updates.append((ip, domain,))
            updates.append((ip, latest_domain,))
        self.db.set_items(updates)
        self.ips = {}

class MyDb:

    def __init__(self):
        self.con = None

    def close(self):
        if not self.con is None:
            self.con.close()

    def __getcon__(self):
        if self.con is None:
            con = mysql.connect(host='vega', user='bindrev', password='verdnib', database='bindrev',
                    auth_plugin='mysql_native_password')
            self.con = con
        return self.con

    def __reset__(self):
        self.con = None

    def __getitem__(self, key):
        try:
            con = self.__getcon__()
            curs = con.cursor()
            curs.execute("SELECT domain FROM ips WHERE ip = %s AND latest = TRUE", (key,))
            results = curs.fetchall()
        except:
            self.__reset__()
            raise

        if len(results) == 0:
            raise KeyError
        return results[0][0]

    def __setitem__(self, key, value):
        self.set_items([(key, value,)])

    def set_items(self, items):
        start = time.time()
        try:
            con = self.__getcon__()
            curs = con.cursor()
            self._set_items(curs, items)
            con.commit()
        except:
            self.__reset__()
            raise
        stop = time.time()
        logging.debug("set_items(size=%s): %s" % (len(items), stop - start))

    def _set_items(self, curs, items):
        for (key, value) in items:
            curs.execute("SELECT id, latest FROM bindrev.ips WHERE ip = %s AND domain = %s", (key, value,))
            results = curs.fetchall()
            update_others = False
            if len(results) == 0:
                curs.execute("INSERT INTO bindrev.ips (ip, domain, latest) VALUES (%s, %s, TRUE)", (key, value,))
                update_others = True
            elif len(results) == 1:
                _id = results[0][0]
                latest = results[0][1]
                if latest == False:
                    curs.execute("UPDATE bindrev.ips SET latest = TRUE WHERE id = %s" % (_id,))
                    update_others = True
            else:
                raise Exception("unexpected result count")
            if update_others:
                curs.execute("UPDATE bindrev.ips SET latest = FALSE WHERE ip = %s AND domain <> %s", (key, value,))
     
    def __contains__(self, key):
        try:
            self.__getitem__(key)
            return True
        except KeyError:
            return False 

class ReverseLookup:

    def __init__(self, db):
        self.db = db

    def add(self, ip_, domain, addr_):
        addr = ipaddress.ip_address(addr_).compressed
        ip = ipaddress.ip_address(ip_).compressed
        if ip in self.db:
            current = self.db[ip]
            if current == domain:
                logging.debug("Keeping %s[%s] -> %s [count=%s] (%s)" % (ip, current, domain, 0, addr))
            else:
                logging.debug("Updating %s[%s] -> %s [count=%s] (%s)" % (ip, current, domain, 0, addr))
                self.db[ip] = domain
        else:
            logging.debug("Creating %s -> %s [count=%s] (%s)" % (ip, domain, 0, addr))
            self.db[ip] = domain

    def get(self, ip_):
        ip = ipaddress.ip_address(ip_).compressed
        if ip in self.db:
            domain = self.db[ip]
            return domain
        return None

def process_frame(lookup, frame):
    dnstap = dnstap_pb2.Dnstap()
    if (not dnstap.type == dnstap_pb2.Dnstap.MESSAGE):
        logging.warn("Unknown dnstap message type: %s" % dnstap.type)
        return
    dnstap.ParseFromString(frame.payload)
    message = dnstap.message
    if (message.type == dnstap_pb2.Message.CLIENT_RESPONSE):
        m = dns.message.from_wire(message.response_message)
        linker = {}
        for answer in m.answer:
            name = str(answer.name)
            if (not name in linker):
                linker[name] = []
            for item in answer.items:
                linker[name].append(item)
        for question in m.question:
            if (not len(question.items) == 0):
                raise Exception("Unexpected items under question: %s" % question)
            if (not question.rdtype in [dns.rdatatype.A, dns.rdatatype.AAAA]):
                continue
            q = []
            questionname = str(question.name)
            q.append(questionname)
            while (not len(q) == 0):
                name = q.pop()
                if (not name in linker):
                    continue
                for item in linker[name]:
                    itemname = str(item)
                    if (item.rdtype in [dns.rdatatype.A, dns.rdatatype.AAAA]):
                        lookup.add(itemname, questionname, message.query_address)
                    elif (item.rdtype in [dns.rdatatype.PTR, dns.rdatatype.CNAME]):
                        q.append(itemname)
                    else:
                        pass

async def setup():

    db = BufferedDb(MyDb())
    async def flusher():
        while True:
            await asyncio.sleep(60)
            try:
                db.flush()
            except Exception as e:
                logging.error(e)
    asyncio.create_task(flusher())
    lookup = ReverseLookup(db)

    def callback(frame):
        try:
            process_frame(lookup, frame)
        except Exception as e:
            logging.error(e)

    frameStreamServer = frames.UnixFrameStreamServer("/var/run/bindrev.sock", callback)
    await frameStreamServer.start()

    async def requestHandler(session, ip):
        if ip == "test":
            return None
        return lookup.get(ip)

    loop = asyncio.get_event_loop()
    requestServer = arpc.arpc.ArpcServer(loop, '0.0.0.0', 8888, requestHandler)
    await requestServer.start()

    def signal_handler(sig, frame):
        db.close()
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

if __name__ == "__main__":
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    loop = asyncio.get_event_loop()

    loop.run_until_complete(setup())
    loop.run_forever()
