#!/usr/bin/env python3.7

import os
import json
import time
import signal
import asyncio
import logging
import dns.message
import dns.rdatatype
import ipaddress
import aiomysql
import dnstap_client
import argparse

default_config_file = "%s/.bindrev.json" % os.path.expanduser('~')

class BufferedDb:

    def __init__(self, db):
        self.db = db
        self.ips = {}

    async def close(self):
        await self.flush()
        await self.db.close()

    async def get(self, ip):
        if ip in self.ips:
            for (domain, latest) in self.ips[ip].items():
                if latest:
                    return domain
            raise Exception("ip present, but latest not found") 
        else:
            return await self.db.get(ip)

    async def set_all(self, items):
        for (ip, domain) in items:
            if not ip in self.ips:
                self.ips[ip] = {}
            self.ips[ip][domain] = True
            for x in self.ips[ip]:
                if x != domain:
                    self.ips[ip][x] = False

    async def flush(self):
        updates = []
        for ip in self.ips:
            for (domain, latest) in self.ips[ip].items():
                if latest:
                    latest_domain = domain
                else:
                    updates.append((ip, domain,))
            updates.append((ip, latest_domain,))
        await self.db.set_all(updates)
        self.ips = {}

class MyDb:

    def __init__(self, host, db, user, password):
        self.host = host
        self.db = db
        self.user = user
        self.password = password
        self.pool = None

    async def close(self):
        if self.pool is not None:
            self.pool.close()
            await self.pool.wait_closed()

    async def __getpool__(self):
        if self.pool is None:
            self.pool = await aiomysql.create_pool(
                    host=self.host, port=3306, user=self.user,
                    password=self.password, db=self.db)
        return self.pool

    async def get(self, ip):
        pool = await self.__getpool__()
        async with pool.acquire() as conn:
            async with conn.cursor() as curs:
                return await self._get(curs, ip)

    async def _get(self, curs, ip):
        await curs.execute("SELECT domain FROM ips WHERE ip = %s AND latest = TRUE", (str(ip),))
        results = await curs.fetchall()
        if len(results) == 0:
            raise KeyError
        return results[0][0]

    async def set_all(self, items):
        start = time.time()
        pool = await self.__getpool__()
        async with pool.acquire() as conn:
            async with conn.cursor() as curs:
                await self._set_all(curs, items)
            await conn.commit()
        stop = time.time()
        logging.debug("set_all(size=%s): %s" % (len(items), stop - start))

    async def _set_all(self, curs, items):
        for (ip, domain) in items:
            await curs.execute("SELECT id, latest FROM bindrev.ips WHERE ip = %s AND domain = %s", (str(ip), domain,))
            results = await curs.fetchall()
            update_others = False
            if len(results) == 0:
                await curs.execute("INSERT INTO bindrev.ips (ip, domain, latest) VALUES (%s, %s, TRUE)", (str(ip), domain,))
                update_others = True
            elif len(results) == 1:
                _id = results[0][0]
                latest = results[0][1]
                if latest == False:
                    await curs.execute("UPDATE bindrev.ips SET latest = TRUE WHERE id = %s" % (_id,))
                    update_others = True
            else:
                raise Exception("unexpected result count")
            if update_others:
                await curs.execute("UPDATE bindrev.ips SET latest = FALSE WHERE ip = %s AND domain <> %s", (str(ip), domain,))
     
class ReverseLookup:

    def __init__(self, db):
        self.db = db

    async def add(self, ip, domain):
        try:
            current = await self.db.get(ip)
            if current == domain:
                logging.debug("Keeping %s[%s] -> %s" % (ip, current, domain))
            else:
                logging.debug("Updating %s[%s] -> %s" % (ip, current, domain))
                await self.db.set_all([(ip, domain,)])
        except KeyError:
            logging.debug("Creating %s -> %s" % (ip, domain))
            await self.db.set_all([(ip, domain,)])

    async def get(self, ip):
        try:
            return await self.db.get(ip)
        except KeyError:
            return None

class BindrevServer:

    test_ip = ipaddress.ip_address('127.0.0.1')
    test_domain = 'localhost.'

    def __init__(self, lookup, host='0.0.0.0', port=8888):
        self.lookup = lookup
        self.host = host
        self.port = port

    async def start(self):
        async def handle(reader, writer):
            try:
                while True:
                    ip_sz = int.from_bytes(await reader.readexactly(1), byteorder='big')
                    if ip_sz == 0:
                        writer.write((0).to_bytes(1, byteorder='big'))
                        break
                    ip = ipaddress.ip_address(await reader.readexactly(ip_sz))
                    if ip == BindrevServer.test_ip:
                        domain = BindrevServer.test_domain
                    else:
                        domain = await self.lookup.get(ip)
                    if domain is None:
                        writer.write((0).to_bytes(1, byteorder='big'))
                    else:
                        domain_sz = len(domain).to_bytes(1, byteorder='big')
                        writer.write(domain_sz)
                        writer.write(domain.encode('utf-8'))
            finally:
                writer.close()

        await asyncio.start_server(handle, self.host, self.port)

async def main():
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s [%(levelname)s]: %(message)s')

    parser = argparse.ArgumentParser()
    parser.add_argument('-c', default=default_config_file, help='config file')
    args = parser.parse_args()

    with open(args.c, 'r') as infile:
        config = json.load(infile)

    my_host = config['my_host']
    my_db = config['my_db']
    my_user = config['my_user']
    my_password = config['my_password']
    mydb = MyDb(my_host, my_db, my_user, my_password)

    db = BufferedDb(mydb)
    async def flusher():
        while True:
            await asyncio.sleep(5)
            try:
                await db.flush()
            except Exception as e:
                logging.error(e)
    asyncio.create_task(flusher())

    lookup = ReverseLookup(db)

    async def tapper_callback(domain, ip):
        await lookup.add(ip, domain)

    tapper = dnstap_client.Tapper(tapper_callback)
    asyncio.create_task(tapper.loop())

    server = BindrevServer(lookup)
    await server.start()

    finish = asyncio.Event()
    def signal_handler(*args):
        finish.set()
    loop = asyncio.get_event_loop()
    loop.add_signal_handler(signal.SIGINT, signal_handler)
    loop.add_signal_handler(signal.SIGTERM, signal_handler)

    try:
        await finish.wait()
    finally:
        await db.close()

if __name__ == "__main__":
    asyncio.run(main())
