#!/usr/bin/env python3.7

import time
import signal
import dnstap_pb2
import asyncio
import logging
import dns.message
import dns.rdatatype
import ipaddress
import uvloop
import mysql.connector as mysql

import sys 
sys.path.append("/home/drew/src/arpc")
import arpc
import arpc.arpc

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s [%(levelname)s]: %(message)s')

class BufferedDb:

    def __init__(self, db):
        self.db = db
        self.ips = {}

    def close(self):
        self.flush()
        self.db.close()

    def __getitem__(self, key):
        if key in self.ips:
            for kv in self.ips[key].items():
                if kv[1] == True:
                    return kv[0]
            raise Exception("key present, but latest not found") 
        else:
            return self.db[key]

    def __setitem__(self, key, value):
        if key in self.ips:
            self.ips[key][value] = True
            for domain in self.ips[key]:
                if domain != value:
                    self.ips[key][domain] = False
        else:
            self.ips[key] = {
                value: True
            }

    def set_items(self, items):
        for (key, value) in items:
            self[key] = value

    def __contains__(self, key):
        try:
            self.__getitem__(key)
            return True
        except KeyError:
            return False

    def flush(self):
        updates = []
        for ip in self.ips:
            for (domain, latest) in self.ips[ip].items():
                if latest:
                    latest_domain = domain
                else:
                    updates.append((ip, domain,))
            updates.append((ip, latest_domain,))
        self.db.set_items(updates)
        self.ips = {}

class MyDb:

    def __init__(self):
        self.con = None

    def close(self):
        if not self.con is None:
            self.con.close()

    def __getcon__(self):
        if self.con is None:
            con = mysql.connect(host='vega', user='bindrev', password='verdnib', database='bindrev',
                    auth_plugin='mysql_native_password')
            self.con = con
        return self.con

    def __reset__(self):
        self.con = None

    def __getitem__(self, key):
        try:
            con = self.__getcon__()
            curs = con.cursor()
            curs.execute("SELECT domain FROM ips WHERE ip = %s AND latest = TRUE", (key,))
            results = curs.fetchall()
        except:
            self.__reset__()
            raise

        if len(results) == 0:
            raise KeyError
        return results[0][0]

    def __setitem__(self, key, value):
        self.set_items([(key, value,)])

    def set_items(self, items):
        start = time.time()
        try:
            con = self.__getcon__()
            curs = con.cursor()
            self._set_items(curs, items)
            con.commit()
        except:
            self.__reset__()
            raise
        stop = time.time()
        logging.debug("set_items(size=%s): %s" % (len(items), stop - start))

    def _set_items(self, curs, items):
        for (key, value) in items:
            curs.execute("SELECT id, latest FROM bindrev.ips WHERE ip = %s AND domain = %s", (key, value,))
            results = curs.fetchall()
            update_others = False
            if len(results) == 0:
                curs.execute("INSERT INTO bindrev.ips (ip, domain, latest) VALUES (%s, %s, TRUE)", (key, value,))
                update_others = True
            elif len(results) == 1:
                _id = results[0][0]
                latest = results[0][1]
                if latest == False:
                    curs.execute("UPDATE bindrev.ips SET latest = TRUE WHERE id = %s" % (_id,))
                    update_others = True
            else:
                raise Exception("unexpected result count")
            if update_others:
                curs.execute("UPDATE bindrev.ips SET latest = FALSE WHERE ip = %s AND domain <> %s", (key, value,))
     
    def __contains__(self, key):
        try:
            self.__getitem__(key)
            return True
        except KeyError:
            return False 

class ReverseLookup:

    def __init__(self, db):
        self.db = db

    def add(self, ip_, domain):
        ip = ip_.compressed
        if ip in self.db:
            current = self.db[ip]
            if current == domain:
                logging.debug("Keeping %s[%s] -> %s [count=%s]" % (ip, current, domain, 0))
            else:
                logging.debug("Updating %s[%s] -> %s [count=%s]" % (ip, current, domain, 0))
                self.db[ip] = domain
        else:
            logging.debug("Creating %s -> %s [count=%s]" % (ip, domain, 0))
            self.db[ip] = domain

    def get(self, ip_):
        ip = ipaddress.ip_address(ip_).compressed
        if ip in self.db:
            domain = self.db[ip]
            return domain
        return None

class Tapper:

    def __init__(self, callback, host='127.0.0.1', port=8765):
        self.callback = callback
        self.host = host
        self.port = port

    async def loop(self):
        async def process(reader):
            while True:
                ip_sz = int.from_bytes(await reader.readexactly(1), byteorder='big')
                ip = ipaddress.ip_address(await reader.readexactly(ip_sz))
                domain_sz = int.from_bytes(await reader.readexactly(1), byteorder='big')
                domain = (await reader.readexactly(domain_sz)).decode('utf-8')
                try:
                    await self.callback(domain, ip)
                except Exception as e:
                    logging.error(e)

        while True:
            try:
                reader, writer = await asyncio.open_connection(self.host, self.port)
                await process(reader)
            except (ConnectionRefusedError, asyncio.streams.IncompleteReadError) as e:
                logging.error(e)
            await asyncio.sleep(1)

async def setup():
    db = BufferedDb(MyDb())
    async def flusher():
        while True:
            await asyncio.sleep(60)
            try:
                db.flush()
            except Exception as e:
                logging.error(e)
    asyncio.create_task(flusher())

    lookup = ReverseLookup(db)

    async def tapper_callback(domain, ip):
        lookup.add(ip, domain)

    tapper = Tapper(tapper_callback)
    asyncio.create_task(tapper.loop())

    async def arpc_callback(session, ip):
        if ip == "test":
            return None
        return lookup.get(ip)

    loop = asyncio.get_event_loop()
    requestServer = arpc.arpc.ArpcServer(loop, '0.0.0.0', 8888, arpc_callback)
    await requestServer.start()

    def signal_handler(sig, frame):
        db.close()
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

if __name__ == "__main__":
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    loop = asyncio.get_event_loop()

    loop.run_until_complete(setup())
    loop.run_forever()
