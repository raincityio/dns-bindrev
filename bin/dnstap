#!/usr/bin/env python3.7

import signal
import dnstap_pb2
import asyncio
import logging
import dns.message
import dns.rdatatype
import ipaddress
import uvloop
import frames
import sys 

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s [%(levelname)s]: %(message)s')

def process_frame(frame):
    dnstap = dnstap_pb2.Dnstap()
    if (not dnstap.type == dnstap_pb2.Dnstap.MESSAGE):
        logging.warn("Unknown dnstap message type: %s" % dnstap.type)
        return
    dnstap.ParseFromString(frame.payload)
    message = dnstap.message
    lookups = []
    if (message.type == dnstap_pb2.Message.CLIENT_RESPONSE):
        m = dns.message.from_wire(message.response_message)
        linker = {}
        for answer in m.answer:
            name = str(answer.name)
            if (not name in linker):
                linker[name] = []
            for item in answer.items:
                linker[name].append(item)
        for question in m.question:
            if (not len(question.items) == 0):
                raise Exception("Unexpected items under question: %s" % question)
            if (not question.rdtype in [dns.rdatatype.A, dns.rdatatype.AAAA]):
                continue
            q = []
            questionname = str(question.name)
            q.append(questionname)
            while (not len(q) == 0):
                name = q.pop()
                if (not name in linker):
                    continue
                for item in linker[name]:
                    itemname = str(item)
                    if (item.rdtype in [dns.rdatatype.A, dns.rdatatype.AAAA]):
                        lookups.append((questionname, itemname,))
                    elif (item.rdtype in [dns.rdatatype.PTR, dns.rdatatype.CNAME]):
                        q.append(itemname)
                    else:
                        pass
    return lookups

class Spanner:

    def __init__(self):
        self.queue = asyncio.Queue()
        self.writers = []

    async def add(self, lookups):
        await self.queue.put(lookups)

    async def setup(self):
        async def handle(reader, writer):
            self.writers.append(writer)

        await asyncio.start_server(handle, '0.0.0.0', 8765)

    async def loop(self):
        while True:
            lookups = await self.queue.get()
            to_close = set()
            for (raw_domain, raw_ip) in lookups:
                logging.debug("%s = %s" % (raw_domain, raw_ip))
                domain = raw_domain.encode('utf-8')
                domain_sz = len(domain).to_bytes(1, byteorder='big')
                ip = ipaddress.ip_address(raw_ip).packed
                ip_sz = len(ip).to_bytes(1, byteorder='big')
                for writer in self.writers:
                    try:
                        writer.write(domain_sz)
                        writer.write(domain)
                        writer.write(ip_sz)
                        writer.write(ip)
                    except Exception as e:
                        logging.error(e)
                        to_close.add(writer)
            for writer in self.writers:
                try:
                    await writer.drain()
                except Exception as e:
                    logging.error(e)
                    to_close.add(writer)
            for writer in to_close:
                try:
                    writer.close()
                except Exception as e:
                    logging.error(e)
                self.writers.remove(writer)

async def setup():
    spanner = Spanner()
    await spanner.setup()
    asyncio.create_task(spanner.loop())

    async def frame_callback(frame):
        lookups = process_frame(frame)
        if not len(lookups) == 0:
            await spanner.add(lookups)

    frameStreamServer = frames.UnixFrameStreamServer("/var/run/bindrev.sock", frame_callback)
    await frameStreamServer.start()

    def signal_handler(sig, frame):
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

if __name__ == "__main__":
    # uvloop seems to have a bug where if the unix
    # server is started after a queue.get await is
    # called, then the unix server does not process
    # connections coming in
#    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    loop = asyncio.get_event_loop()

    loop.run_until_complete(setup())
    loop.run_forever()
